[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Digital Literacy",
    "section": "",
    "text": "Vorwort",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#aufbau-des-buches",
    "href": "index.html#aufbau-des-buches",
    "title": "Digital Literacy",
    "section": "Aufbau des Buches",
    "text": "Aufbau des Buches\nDie folgende Abbildung zeigt die Kompetenzen, die in diesem Buch vermittelt werden. Die unteren drei Blöcke stehen für das Wissen, wie Informationen in digitalen Computern abgebildet werden (representation), wie sie verarbeitet werden (processing) und wie wir beides für unsere Zwecke einsetzen können, um Probleme zu lösen (programming). Diese Bereiche sind die Grundlagen der Digitalisierung und deren Beherrschung ist die Voraussetzung für eine weitergehende Auseinandersetzung mit dem Thema. Diese erfolgt im Rahmen dieses Buches mit der Betrachtung der beiden wichtigsten Anwendungsfelder der Digitalisierung aus Sicht einer digital mündigen Person. Zum einen steigen wir in die Hintergründe der Künstlichen Intelligenz (artificial intelligence) ein, eine Entwicklung, die ein nie zuvor gesehenens Transformationspotenzial besitzt. Als zweite Säule digitaler Anwendungen beschäftigen wir uns mit den Möglichkeiten der Datenanalyse (data analysis), die durch die wachsende Menge digitaler Prozesse und Daten jeden Tag an Relevanz gewinnt.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#material",
    "href": "index.html#material",
    "title": "Digital Literacy",
    "section": "Material",
    "text": "Material\nDie Abbildungen aus diesem Buch entstammen den zugehörigen Vorlesungsfolien und sind hier zu finden:\n\nDigitalisierung (Repräsentation, Verarbeitung, Programmierung)\n\nGoogle Slides\nPDF\n\nKünstliche Intelligenz\n\nGoogle Slides\nPDF\n\nDatenanalyse\n\nGoogle Slides\nPDF",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#inspiration-für-dieses-buch",
    "href": "index.html#inspiration-für-dieses-buch",
    "title": "Digital Literacy",
    "section": "Inspiration für dieses Buch",
    "text": "Inspiration für dieses Buch\nIn dieses Buch sind viele Ideen aus den CS50-Kursen von David J. Malan und seinem fantastischen Team eingeflossen. Ich kann die Kurse sehr empfehlen und euch speziell als Ergänzung zu diesem Buch die folgenden ans Herz legen:\n\nCS50’s Introduction to Programming with Python (2022)\nCS50: Introduction to Computer Science (2023)\n\nBesonders im ersten Teilen dieses Buchs, in denen es um die Grundlagen der Digitalisierung und digitaler Computer geht, hat mich Charles Petzold (2022) mit seinem Buch Code: The Hidden Language of Computer Hardware and Software inspiriert. Es ist ein verständlich geschriebenes und gut lesbares Buch, das mittlerweile in der zweiten Auflage vorliegt. Ich empfehle es allen, die sich für die Grundlagen der Informatik interessieren.\nIm Teil zur Datenanalyse greife ich auf viele Ideen und Beispiele aus dem Klassiker R for Data Science von Hadley Wickham (2023) zurück. Dieses Buch wurde 2023 als überarbeitete zweite Auflage veröffentlicht und ist die beste Einführung in die explorative Datenanalyse mit R, die ich kenne. Dazu empfehle ich den Onlinekurs CS50R - Introdiction to Programming with R von Carter Zenke, dessen Vorlesungen allesamt auf YouTube zu finden sind.\n\n\n\n\nPetzold, Charles. 2022. Code: The Hidden Language of Computer Hardware and Software. 2nd ed. Hoboken: Microsoft Press.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for data science: import, tidy, transform, visualize, and model data. 2nd edition. Sebastopol, CA: O’Reilly Media, Inc.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "chapters/representation/problems.html",
    "href": "chapters/representation/problems.html",
    "title": "1  Probleme",
    "section": "",
    "text": "1.1 Ein Modell für die Problemlösung\nAls ehemaliger Berater wurde mir beigebracht, den Begriff “Problem” zu vermeiden, weil er negativ konnotiert ist. Stattdessen sollte man von Herausforderungen sprechen, was den positiven Aspekt hervorhebt. In diesem Kapitel ist der Begriff “Problem” abstrakter gemeint. Es geht um das Bewältigen einer Aufgabe, die komplex, wie das Durchsuchen von mehreren Milliarden Datensätzen, oder einfach, wie das Addieren von 1 und 1, sein kann.\nEgal, wie komplex das Problem ist, wir können seine Lösung mithilfe eines digitalen Computers auf ein einfaches Modell reduzieren. Dieses Modell werden wir im Laufe des Buches an verschiedenen Stellen wiedersehen. Das Modell in Abbildung 1.1 hat drei Bestandteile:\nNehmen wir das Beispiel der Addition zweier ganzer Zahlen \\(a\\) und \\(b\\). Die Eingabe besteht für dieses einfache Problem aus konkreten Werten für \\(a\\) und \\(b\\). Die Lösung für das Problem bekommen wir, wenn wir den Additionsoperator \\(+\\) auf die beiden Zahlen aus der Eingabe anwenden. Als Ergebnis bekommen wir die sogenannte Summe, die wir mit \\(s\\) abkürzen. Also: \\(a + b = s\\)",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "chapters/representation/problems.html#ein-modell-für-die-problemlösung",
    "href": "chapters/representation/problems.html#ein-modell-für-die-problemlösung",
    "title": "1  Probleme",
    "section": "",
    "text": "Die Eingabe ist das, was wir zur genaueren Beschreibung des Problems wissen müssen. Das können etwa die zwei Zahlen sein, die miteinander addiert werden sollen. Oder sind die Milliarden Datensätze zusammen mit der Information, wonach wir suchen.\nDie Beschreibung der notwendigen Schritte, um das Problem auf Basis der Eingabe zu lösen. Später werden wir hierfür den Begriff Algorithmus einführen.\nDie Ausgabe ist Repräsentation der Lösung des Problems. Das kann eine Zahl sein, wie das Ergebnis der Addition zweier Zahlen. Es kann auch ein Datensatz sein, der aus mehreren Milliarden als der Gesuchte erkannt wurde.\n\n\n\n\n\n\n\nAbbildung 1.1: Ein Modell für das Lösen von Problemen.\n\n\n\n\n\n\n\nAddition als Beispiel für das Lösen eines Problems.",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "chapters/representation/problems.html#problemlösung-als-informationsverarbeitung",
    "href": "chapters/representation/problems.html#problemlösung-als-informationsverarbeitung",
    "title": "1  Probleme",
    "section": "1.2 Problemlösung als Informationsverarbeitung",
    "text": "1.2 Problemlösung als Informationsverarbeitung\nModelle sind wie vereinfachte Landkarten für komplexe Themen. Stellt euch vor, ihr nehmt einen komplizierten Sachverhalt und entfernt alles, was für euer Ziel nicht wichtig ist. Am Ende bleibt ein Modell übrig, das nur die Kernpunkte beinhaltet. Nehmen wir als Beispiel ein Modell, das erklärt, wie die Informationsverarbeitung in unseren digitalen Computern funktioniert. Hier konzentrieren wir uns auf drei Schlüsselelemente.\nErstens gibt es die Eingabe. Das ist das, was ihr dem Computer sagt oder gebt, also eure Fragen, Informationen oder Befehle. Dann kommt das Programm selbst, das wir zuerst als Blackbox betrachten – also als etwas Geheimnisvolles, dessen Inneres wir bis jetzt nicht kennen. Später werden wir dieses Unbekannte durch unterschiedliche Anwendungen ersetzen. Und schließlich haben wir die Ausgabe, also das, was der Computer nach der Verarbeitung eurer Eingabe zurückgibt.\n\n\n\n\n\n\nAbbildung 1.2: Ein Modell für die Informationsverarbeitung digitaler Computer.",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "chapters/representation/problems.html#übungen",
    "href": "chapters/representation/problems.html#übungen",
    "title": "1  Probleme",
    "section": "Übungen",
    "text": "Übungen\n\nFormuliert drei weitere Probleme mithilfe des vorgestellten Modells für die Problemlösung mittels digitaler Computer. Nennt jeweils die Eingabe, Lösung und die Ausgabe des Problems!\n\n\n\n\nAbbildung 1.1: Ein Modell für das Lösen von Problemen.\nAddition als Beispiel für das Lösen eines Problems.\nAbbildung 1.2: Ein Modell für die Informationsverarbeitung digitaler Computer.",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "chapters/representation/information.html",
    "href": "chapters/representation/information.html",
    "title": "2  Information",
    "section": "",
    "text": "2.1 Schach\nWir beginnen dieses Kapitel mit einer kurzen Geschichte:\nIn einer Zeit, lange bevor digitale Technologien wie Smartphones, Tablets oder PCs unseren Alltag bereicherten, lebten zwei neunjährige Kinder, Max und Ida, als beste Freunde in einem kleinen Dorf. Max wohnte in einem Haus, das gute 200 Meter von Idas Zuhause entfernt lag. Zwischen beiden Häusern lag nichts außer einem weiten Feld.\nMax und Ida teilten eine besondere Leidenschaft: das Schachspiel. Sie nutzten jede freie Minute des Tages, um gegeneinander anzutreten, es sei denn, ihre Eltern schickten sie zum Spielen nach draußen. Da der Tag oft zu kurz für ihre ausgiebigen Partien war, wollten sie ihre Schachspiele auch abends fortsetzen – eine Zeit, in der es ruhig im Haus war und sie sich voll und ganz auf das Spiel konzentrieren konnten.\nDoch ein Problem stand im Weg: In der Schulzeit war es ihnen nicht gestattet, spätabends miteinander zu telefonieren, da ausreichend Schlaf essentiell für die Aufmerksamkeit in der Schule ist. Zudem war das Telefonieren zu jener Zeit eine kostspielige Angelegenheit, da jede Minute berechnet wurde. Handys und Tablets, die diese Hürde hätten überwinden können, waren noch nicht erfunden – und selbst wenn, wären sie für Kinder ihres Alters kaum zugänglich gewesen. Doch Max und Ida ließen sich nicht entmutigen und suchten nach einer kreativen Lösung, um ihr Spiel auch unter diesen Umständen fortsetzen zu können.\nGlücklicherweise bot sich eine Lösung an: Die Fenster ihrer Kinderzimmer waren so positioniert, dass sie direkten Sichtkontakt zueinander hatten. Licht anzumachen war keine Option – das hätten die Eltern sofort bemerkt. Doch beide hatten zu ihrem letzten Geburtstag je eine Taschenlampe geschenkt bekommen…\nHier endet die Geschichte von Max und Ida und ihrer Leidenschaft für Schach. Nun setzen wir unsere Reise in die digitale Welt fort und stellen uns die Frage: Wie können Max und Ida mit nichts weiter als einer Taschenlampe ihre Schachzüge kommunizieren?\nUm diese Frage zu beantworten, müssen wir zuerst verstehen, wie sich die Information eines Schachzugs präzise ausdrücken lässt. Jeder, der schon einmal Schach gespielt hat, weiß, dass das Brett quadratisch ist und aus 64 Feldern besteht, aufgeteilt in schwarze und weiße Quadrate. Durch die Kennzeichnung der horizontalen Reihen mit Buchstaben und der vertikalen Reihen mit Zahlen lässt sich jedes Feld eindeutig identifizieren. So steht beispielsweise der weiße König in der Abbildung 2.1 auf dem Feld d1 – wir sprechen hier von der Koordinate des Feldes. Ein Schachzug lässt sich demnach als Bewegung von einer Koordinate zur nächsten darstellen, wie im Zug c2 nach c4 in Abbildung 2.2, der einfach als c2c4 notiert wird. Diese Art der Notation ermöglicht es, den Spielstand nach jedem Zug genau zu erfassen, wobei im professionellen Bereich eine erweiterte Notation, wie etwa die ausführliche algebraische Notation, zum Einsatz kommt, die auch die Schachfiguren und das Schlagen von Gegnern miteinbezieht.\nFür unsere Zwecke und die Kommunikation zwischen Max und Ida halten wir uns jedoch an die einfache Notation, um Schachzüge als vierstellige Zeichenketten darzustellen. Doch wie lässt sich eine solche Zeichenkette mit einer Taschenlampe übermitteln? Dazu müssen wir zunächst klären, was Information ist und wie sie übertragen werden kann.",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "chapters/representation/information.html#schach",
    "href": "chapters/representation/information.html#schach",
    "title": "2  Information",
    "section": "",
    "text": "Abbildung 2.1: Ein Schachbrett im Endspiel. Der weiße König steht auf d1.\n\n\n\n\n\n\n\n\n\nAbbildung 2.2: Der Bauer bewegt sich von c2 nach c4, was wir mit der Zeichenkette c2c4 darstellen.",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "chapters/representation/information.html#information-braucht-variation",
    "href": "chapters/representation/information.html#information-braucht-variation",
    "title": "2  Information",
    "section": "2.2 Information braucht Variation",
    "text": "2.2 Information braucht Variation\nInformation existiert nur, wenn wir die Freiheit haben, innerhalb einer Sequenz aus einer Reihe verschiedener Symbole zu wählen. Dies mag zunächst abstrakt klingen, aber ein Beispiel verdeutlicht es schnell.\n\nSymbolvielfalt\nStellt euch vor, unser Alphabet bestünde nur aus dem Buchstaben “A”, und zwar ausschließlich in Großbuchstaben. Nehmen wir weiter an, eine Sequenz - oder Nachricht - dürfte genau zwei Zeichen lang sein. Können wir unter diesen Bedingungen Informationen übermitteln? Die Antwort ist nein, denn unsere einzige Nachricht wäre immer “AA”. Mit diesen Einschränkungen ist unsere Nachricht wertlos, da sie keine Information trägt.\nErst die Variation der Symbole innerhalb einer Nachricht, und damit die Erzeugung unterschiedlicher Nachrichten, ermöglicht die Entstehung von Information. Fügen wir dem “A” ein “B” hinzu, ergeben sich bereits vier mögliche Nachrichten mit der Länge von zwei Zeichen: AA, AB, BA, BB.\nMit einem dritten Symbol, “C”, erweitert sich unser Repertoire auf neun Nachrichten:\n\n\n\n\n\n\nAbbildung 2.3: Mit 2 Stellen und 3 Symbolen gibt es 9 Möglichkeiten.\n\n\n\nFügen wir ein viertes Symbol, “D”, hinzu, erreichen wir schon 16 mögliche Nachrichten:\n\n\n\n\n\n\nAbbildung 2.4: Mit 2 Stellen und 4 Symbolen gibt es 16 Möglichkeiten.\n\n\n\nInteressanterweise scheint die Anzahl möglicher Nachrichten mit der Quadratzahl der verfügbaren Symbole zu steigen:\n\n1 Symbol → 1 Nachricht\n2 Symbole → 4 Nachrichten\n3 Symbole → 9 Nachrichten\n\nBei fünf Symbolen wären es demnach 25 Nachrichten, was unsere Vermutung bestätigt:\n\n\n\n\n\n\nAbbildung 2.5: Mit 2 Stellen und 5 Symbolen gibt es 25 Möglichkeiten.\n\n\n\nAber warum genau potenzieren wir die Anzahl der Symbole in dem Beispiel mit 2? Womit könnte das zusammenhängen?\n\n\nNachrichtenlänge\nTatsächlich spielt neben der Anzahl der Symbole auch die Länge der Nachricht eine entscheidende Rolle, wie ihr sicher schon vermutet habt. Mit zwei Symbolen und zwei Stellen konnten wir vier Nachrichten abbilden. Erhöhen wir die Länge auf drei Stellen, aber beschränken uns weiterhin auf die Symbole A und B, verdoppeln sich die Möglichkeiten auf acht:\nAAA, AAB, ABA, ABB, BAA, BAB, BBA, BBB.\nExperimentell können wir folgern, dass sich mit jeder zusätzlichen Stelle die Anzahl der möglichen Nachrichten verdoppelt, vorausgesetzt, wir haben nur zwei Symbole. Bei drei Stellen und zwei Symbolen ergeben sich somit 16 unterschiedliche Nachrichten. Jede Nachricht, die wir mit zwei Stellen bereits abbilden konnten, existiert bei drei Stellen in zwei Varianten, jeweils mit einem der beiden Symbole am Ende:\nAAAA, AABA, ABAA, ABBA, BBBA, BAAA, BABA, BBAA\nund\nAAAB, AABB, ABAB, ABBB, BBBB, BAAB, BABB, BBAB\nNehmen wir nun drei Symbole A, B, C und zwei Stellen, haben wir bereits gesehen, dass neun Nachrichten möglich sind. Fügen wir eine dritte Stelle hinzu, verdreifacht sich die Menge der Nachrichten aufgrund der drei möglichen Symbole an jeder neuen Stelle.\nAllgemein ausgedrückt multiplizieren wir die Anzahl der Symbole mit sich selbst, entsprechend der Anzahl der Stellen in einer Nachricht. Dies führt uns zu der Formel für die Berechnung der Anzahl an möglichen Nachrichten \\(N\\):\n\\[\nN = R^n\n\\]\nwobei \\(R\\) die Anzahl der Symbole und \\(n\\) die Anzahl der Stellen in einer Nachricht darstellt.",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "chapters/representation/information.html#kodierung",
    "href": "chapters/representation/information.html#kodierung",
    "title": "2  Information",
    "section": "2.3 Kodierung",
    "text": "2.3 Kodierung\n\nNachrichten\nWir wissen nun, das Information nur Variation entsteht und dass wir folglich unterschiedliche Nachrichten übermitteln können müssen, um Informationen zu teilen. Das bringt uns zurück zur Max und Idas Taschenlampe. Wenn beide auch nachts weiter Schach spielen wollen, müssen sie sich überlegen, welche Nachrichten sie verwenden wollen, um ihre Züge dem Gegenüber mitzuteilen. Dazu müssen sie sich zunächst einmal zwei Dinge überlegen:\n\nWelche Symbole sollen in den Nachrichten verwendet werden?\nWie lang soll oder muss eine Nachricht sein?\n\n\n\nBedeutung\nMax und Ida wissen jetzt, wie viele Symbole sie nutzen wollen und wie lang eine Nachricht sein muss, um die die vier Bestandteile eines Schachzuges zu übermitteln. Die beiden müssen sich nun noch darauf einigen, welche Nachricht welche Bedeutung bekommt. Die beiden benötigen ein Codesystem. driv",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "chapters/representation/information.html#morse-code",
    "href": "chapters/representation/information.html#morse-code",
    "title": "2  Information",
    "section": "2.4 Morse Code",
    "text": "2.4 Morse Code\nHier können Interessierte sich das gesamte Alphabet als Morse Code in Audioform anhören\n\n\n\nAbbildung 2.1: Ein Schachbrett im Endspiel. Der weiße König steht auf d1.\nAbbildung 2.2: Der Bauer bewegt sich von c2 nach c4, was wir mit der Zeichenkette c2c4 darstellen.\nAbbildung 2.3: Mit 2 Stellen und 3 Symbolen gibt es 9 Möglichkeiten.\nAbbildung 2.4: Mit 2 Stellen und 4 Symbolen gibt es 16 Möglichkeiten.\nAbbildung 2.5: Mit 2 Stellen und 5 Symbolen gibt es 25 Möglichkeiten.",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "chapters/representation/codes.html",
    "href": "chapters/representation/codes.html",
    "title": "5  Codes",
    "section": "",
    "text": "Abbildung 5.1: Ein Herz als Pixelmatrix.\n\n\n\n\n\n\nAbbildung 5.1: Ein Herz als Pixelmatrix.",
    "crumbs": [
      "Repräsentation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Codes</span>"
    ]
  },
  {
    "objectID": "chapters/processing/algorithms.html",
    "href": "chapters/processing/algorithms.html",
    "title": "6  Algorithmen",
    "section": "",
    "text": "Das folgende Video empfehle ich als Ergänzung zu diesem Kapitel:\nCS50x 2023 - Lecture 3 - Algorithms",
    "crumbs": [
      "Verarbeitung",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "chapters/processing/arithmetic.html",
    "href": "chapters/processing/arithmetic.html",
    "title": "8  Arithmetik",
    "section": "",
    "text": "8.1 Binäre Addition",
    "crumbs": [
      "Verarbeitung",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arithmetik</span>"
    ]
  },
  {
    "objectID": "chapters/processing/arithmetic.html#zum-weiterlesen",
    "href": "chapters/processing/arithmetic.html#zum-weiterlesen",
    "title": "8  Arithmetik",
    "section": "8.2 Zum Weiterlesen",
    "text": "8.2 Zum Weiterlesen\nFür ein tieferes Verständnis der binären Addition mit Logikgattern empfehle ich das Kapitel 14 “Adding with Logic Gates” aus Petzold (2022).\n\n\n\n\nPetzold, Charles. 2022. Code: The Hidden Language of Computer Hardware and Software. 2nd ed. Hoboken: Microsoft Press.",
    "crumbs": [
      "Verarbeitung",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arithmetik</span>"
    ]
  },
  {
    "objectID": "parts/part_2_programming.html",
    "href": "parts/part_2_programming.html",
    "title": "Programmieren",
    "section": "",
    "text": "In diesem Teil des Buches führen wir die Grundkonzepte der Programmierung ein. Dazu verwenden wir die Sprache Python, die sich mit ihrer Eleganz und Einfachheit hervorragend für den Einstieg in die Programmierung eignet. Später werden wir neben Python noch R als zweite Programmiersprache kennenlernen, wenn wir uns mit der Datenanalyse beschäftigen.",
    "crumbs": [
      "Programmieren"
    ]
  },
  {
    "objectID": "chapters/programming/variables.html",
    "href": "chapters/programming/variables.html",
    "title": "10  Variablen",
    "section": "",
    "text": "# Dies ist eine neue Variable mit dem Namen \"x\"\nx = 1",
    "crumbs": [
      "Programmieren",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Variablen</span>"
    ]
  },
  {
    "objectID": "chapters/programming/control_structures.html",
    "href": "chapters/programming/control_structures.html",
    "title": "11  Kontrollstrukturen",
    "section": "",
    "text": "# Eine If-Anweisung in Pyhton\nif True:\n  ...\nelse:\n  ...",
    "crumbs": [
      "Programmieren",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "parts/part_4_daten.html",
    "href": "parts/part_4_daten.html",
    "title": "Daten",
    "section": "",
    "text": "Dieser letzte Teil des Buches widmet sich der Data Literacy als ein wichtiger Bestandteil von Digital Literacy. Als Standardwerk zum Nachlesen empfehle ich Wickham, Çetinkaya-Rundel, and Grolemund (2023).\n\n\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023. R for data science: import, tidy, transform, visualize, and model data. 2nd edition. Sebastopol, CA: O’Reilly Media, Inc.",
    "crumbs": [
      "Daten"
    ]
  },
  {
    "objectID": "chapters/data/programming_with_r.html",
    "href": "chapters/data/programming_with_r.html",
    "title": "16  Programmieren mit R",
    "section": "",
    "text": "16.1 Variablen",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Programmieren mit R</span>"
    ]
  },
  {
    "objectID": "chapters/data/programming_with_r.html#kontrollstrukturen",
    "href": "chapters/data/programming_with_r.html#kontrollstrukturen",
    "title": "16  Programmieren mit R",
    "section": "16.2 Kontrollstrukturen",
    "text": "16.2 Kontrollstrukturen",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Programmieren mit R</span>"
    ]
  },
  {
    "objectID": "chapters/data/programming_with_r.html#schleifen",
    "href": "chapters/data/programming_with_r.html#schleifen",
    "title": "16  Programmieren mit R",
    "section": "16.3 Schleifen",
    "text": "16.3 Schleifen",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Programmieren mit R</span>"
    ]
  },
  {
    "objectID": "chapters/data/programming_with_r.html#funktionen",
    "href": "chapters/data/programming_with_r.html#funktionen",
    "title": "16  Programmieren mit R",
    "section": "16.4 Funktionen",
    "text": "16.4 Funktionen",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Programmieren mit R</span>"
    ]
  },
  {
    "objectID": "chapters/data/programming_with_r.html#bibliotheken",
    "href": "chapters/data/programming_with_r.html#bibliotheken",
    "title": "16  Programmieren mit R",
    "section": "16.5 Bibliotheken",
    "text": "16.5 Bibliotheken",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Programmieren mit R</span>"
    ]
  },
  {
    "objectID": "chapters/data/data_analysis_with_r.html",
    "href": "chapters/data/data_analysis_with_r.html",
    "title": "17  Explorative Datenanalyse",
    "section": "",
    "text": "17.1 Warum R?",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Explorative Datenanalyse</span>"
    ]
  },
  {
    "objectID": "chapters/data/data_analysis_with_r.html#warum-r",
    "href": "chapters/data/data_analysis_with_r.html#warum-r",
    "title": "17  Explorative Datenanalyse",
    "section": "",
    "text": "R oder Python?\nDiese Frage kann ich nicht eindeutig pro R beantworten. Es gibt gute Gründe, beide Sprachen für die Datenanalyse zu verwenden.\n\nBeide Sprachen sind frei verfügbar und Open Source.\nBeide Sprachen haben in der Praxis eine hohe Verbreitung und damit eine große Community, die sich um die Entwicklung und Pflege der Sprachen und der Pakete kümmert.\n\nDie beiden wichtigsten Gründe, warum ich R bevorzuge, sind:\n\nR ist eine Sprache, die speziell für den Zweck der statistischen Datenanalyse entwickelt und verwendet wird. Python dagegen ist eine allgemeine Programmiersprache, deren größte Stärke in ihrer Vielseitigkeit liegt.\nR und das Tidyverse, ein Metapaket für R, das eine Vielzahl von Paketen für die Datenanalyse zusammenfasst, sind in der Wissenschaft und in der Wirtschaft speziell für die Datenvisualisierung weit verbreitet. Mit gutem Grund: Aus meiner persönlichen Erfahrung mit Python und R heraus kann ich sagen, dass der Arbeitsfluss mit R und dem Tidyverse intuitiver ist und die unterschiedlichen Pakete für das Laden von Daten, die Datentransformation und die Visualisierung von Daten problemlos miteinander verwendet werden können.\n\n\n\nR oder SPSS?\nFür diese Frage empfehle ich euch das Video 17.1.\n\n\n\n\n\n\nVideo 17.1: “Why you should abandon SPSS for R”\n\n\n\n\n\nR oder Excel?\nDie Antwort auf diese Frage folgt der gleichen Argumentation wie der Frage, warum eine digitale Ausbildung mehr als nur die gekonnte und kritische Anwendung von Werkzeugen ausmachen sollte. Kurz gesagt: Wir wollen von Werkzeugnutzern zu Werkzeugbauern werden.",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Explorative Datenanalyse</span>"
    ]
  },
  {
    "objectID": "chapters/data/vectors.html",
    "href": "chapters/data/vectors.html",
    "title": "18  Vektoren",
    "section": "",
    "text": "Ein Vektor ist eine Liste mit Elementen gleichen Typs.",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Vektoren</span>"
    ]
  },
  {
    "objectID": "chapters/data/data_frames.html",
    "href": "chapters/data/data_frames.html",
    "title": "19  Data Frames",
    "section": "",
    "text": "19.1 Tabellen",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "chapters/data/data_frames.html#tibbles",
    "href": "chapters/data/data_frames.html#tibbles",
    "title": "19  Data Frames",
    "section": "19.2 Tibbles",
    "text": "19.2 Tibbles",
    "crumbs": [
      "Daten",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "chapters/references.html",
    "href": "chapters/references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Petzold, Charles. 2022. Code: The Hidden Language of Computer\nHardware and Software. 2nd ed. Hoboken: Microsoft Press.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023.\nR for data science: import, tidy, transform, visualize, and model\ndata. 2nd edition. Sebastopol, CA: O’Reilly Media, Inc.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]